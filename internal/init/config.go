package init

import (
	"fmt"
	"os"
	"path/filepath"
)

// generateConfig creates the conveyor.yml configuration file
func generateConfig(opts *Options, configPath, certDir string) error {
	// Check if config file already exists
	if !opts.Force && fileExists(configPath) {
		return fmt.Errorf("configuration file already exists at %s (use --force to overwrite)", configPath)
	}

	// Use custom config file if provided
	if opts.ConfigFile != "" {
		return copyConfigFile(opts.ConfigFile, configPath)
	}

	// Generate default configuration
	return generateDefaultConfig(opts, configPath, certDir)
}

// copyConfigFile copies a user-provided config file to the target location
func copyConfigFile(srcPath, destPath string) error {
	if err := copyFile(srcPath, destPath); err != nil {
		return fmt.Errorf("failed to copy config file: %w", err)
	}

	fmt.Printf("ðŸ“‹ Copied configuration file to %s\n", destPath)
	return nil
}

// generateDefaultConfig creates a default conveyor.yml configuration
func generateDefaultConfig(opts *Options, configPath, certDir string) error {
	config := fmt.Sprintf(`# Conveyor CI Configuration
# Generated by 'conveyor init'

api:
  port: %d
  auth_enabled: %t

nats:
  port: %d

tls:
  ca: %s
  key: %s
  cert: %s
`,
		opts.APIPort,
		opts.AuthEnabled,
		opts.NatsPort,
		filepath.Join(certDir, "ca.pem"),
		filepath.Join(certDir, "server.key"),
		filepath.Join(certDir, "server.crt"),
	)

	file, err := os.OpenFile(configPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return fmt.Errorf("failed to create config file: %w", err)
	}
	defer file.Close()

	if _, err := file.WriteString(config); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	fmt.Printf("âœ” Generated configuration file: %s\n", configPath)
	return nil
}
